import { Request, Response } from 'express';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import { User, IUser } from '../models/User';
import { AuthRequest } from '../middleware/auth';
import IPinfo from 'ipinfo';

const JWT_SECRET = process.env.JWT_SECRET || 'mmrpayv3!@#';
const IPINFO_TOKEN = process.env.IPINFO_TOKEN || '';

export const register = async (req: Request, res: Response) => {
  try {
    const { login, email, password, phoneNumber, typeOfAccount } = req.body;

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
    const existingUser = await User.findOne({ $or: [{ email }, { login }] });
    if (existingUser) {
      return res.status(400).json({ error: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email –∏–ª–∏ –ª–æ–≥–∏–Ω–æ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç' });
    }

    // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const user = new User({
      login,
      email,
      password,
      phoneNumber,
      typeOfAccount,
      balance: 0,
      verificationStatus: 'not_verified',
      notifications: {
        newRequests: true,
        financialOperations: true,
        systemNotifications: true
      }
    });

    await user.save();

    // –°–æ–∑–¥–∞–µ–º JWT —Ç–æ–∫–µ–Ω
    const token = jwt.sign(
      { id: user._id },
      JWT_SECRET,
      { expiresIn: '24h' }
    );

    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç –±–µ–∑ –ø–∞—Ä–æ–ª—è
    const userResponse = user.toObject();
    delete userResponse.password;

    res.status(201).json({
      user: {
        id: user._id.toString(),
        email: user.email,
        login: user.login,
        typeOfAccount: user.typeOfAccount,
        verificationStatus: user.verificationStatus
      },
      token
    });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏' });
  }
};

export const login = async (req: Request, res: Response) => {
  try {
    console.log('üîë –ü–æ–ø—ã—Ç–∫–∞ –≤—Ö–æ–¥–∞:', { email: req.body.email });
    const { email, password } = req.body;
    const user = await User.findOne({ email });

    if (!user) {
      console.log('‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω:', { email });
      return res.status(401).json({ message: '–ù–µ–≤–µ—Ä–Ω—ã–π email –∏–ª–∏ –ø–∞—Ä–æ–ª—å' });
    }

    console.log('‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–π–¥–µ–Ω:', { 
      email: user.email,
      isLocked: user.isAccountLocked(),
      failedAttempts: user.securitySettings.failedLoginAttempts
    });

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –ª–∏ –∞–∫–∫–∞—É–Ω—Ç
    if (user.isAccountLocked()) {
      console.log('üîí –ê–∫–∫–∞—É–Ω—Ç –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω:', { 
        email,
        lockedUntil: user.securitySettings.accountLockedUntil
      });
      return res.status(403).json({ 
        message: '–ê–∫–∫–∞—É–Ω—Ç –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –∏–∑-–∑–∞ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –Ω–µ—É–¥–∞—á–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫ –≤—Ö–æ–¥–∞' 
      });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è
    if (user.securitySettings.ipRestrictions.enabled) {
      const ipAllowed = user.checkIpRestriction(req.ip);
      if (!ipAllowed) {
        return res.status(403).json({
          message: '–î–æ—Å—Ç—É–ø —Å –≤–∞—à–µ–≥–æ IP-–∞–¥—Ä–µ—Å–∞ –∑–∞–ø—Ä–µ—â–µ–Ω'
        });
      }
    }

    if (user.securitySettings.timeRestrictions.enabled) {
      const timeAllowed = user.checkTimeRestriction();
      if (!timeAllowed) {
        return res.status(403).json({
          message: '–î–æ—Å—Ç—É–ø –≤ –¥–∞–Ω–Ω–æ–µ –≤—Ä–µ–º—è –∑–∞–ø—Ä–µ—â–µ–Ω'
        });
      }
    }

    if (user.securitySettings.geoRestrictions.enabled) {
      const ipinfo = new IPinfo(IPINFO_TOKEN);
      const ip = req.ip || req.socket.remoteAddress || '';
      const ipDetails = await ipinfo.lookupIp(ip);
      const geoAllowed = user.checkGeoRestriction(ipDetails.country || '');
      if (!geoAllowed) {
        return res.status(403).json({
          message: '–î–æ—Å—Ç—É–ø –∏–∑ –≤–∞—à–µ–π —Å—Ç—Ä–∞–Ω—ã –∑–∞–ø—Ä–µ—â–µ–Ω'
        });
      }
    }

    const isMatch = await user.comparePassword(password);
    console.log('üîê –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞—Ä–æ–ª—è:', { isMatch });

    if (!isMatch) {
      console.log('‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å:', { email });
      await user.handleFailedLogin();
      return res.status(401).json({ message: '–ù–µ–≤–µ—Ä–Ω—ã–π email –∏–ª–∏ –ø–∞—Ä–æ–ª—å' });
    }

    // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –Ω–µ—É–¥–∞—á–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫ –ø—Ä–∏ —É—Å–ø–µ—à–Ω–æ–º –≤—Ö–æ–¥–µ
    await user.resetFailedLoginAttempts();

    // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ—Å–ª–µ–¥–Ω–µ–º –≤—Ö–æ–¥–µ
    user.lastLogin = new Date();

    // –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–µ–∫—É—â–µ–º IP –∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ
    const ipAddress = req.ip || req.socket.remoteAddress || '';
    const userAgent = req.headers['user-agent'] || '';
    
    // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏
    let locationInfo: {
      country: string | null;
      region: string | null;
      city: string | null;
    } = {
      country: null,
      region: null,
      city: null
    };

    try {
      const ipinfo = new IPinfo(IPINFO_TOKEN);
      const ipDetails = await ipinfo.lookupIp(ipAddress);
      
      if (ipDetails) {
        locationInfo = {
          country: ipDetails.country || null,
          region: ipDetails.region || null,
          city: ipDetails.city || null
        };
      }
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏:', error);
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —É–∂–µ —Ç–∞–∫–æ–π IP –≤ —Å–ø–∏—Å–∫–µ
    const existingIpIndex = user.ipAddresses.findIndex((ip: { address: string; deviceInfo: string }) => 
      ip.address === ipAddress && ip.deviceInfo === userAgent
    );

    if (existingIpIndex !== -1) {
      // –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
      user.ipAddresses[existingIpIndex].lastUsed = new Date();
      user.ipAddresses[existingIpIndex].location = locationInfo;
    } else {
      // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–π IP
      user.ipAddresses.push({
        address: ipAddress,
        lastUsed: new Date(),
        deviceInfo: userAgent,
        location: locationInfo
      });
    }

    await user.save();

    const token = jwt.sign(
      { id: user._id },
      JWT_SECRET,
      { expiresIn: '24h' }
    );

    res.json({
      user: {
        id: user._id.toString(),
        email: user.email,
        login: user.login,
        typeOfAccount: user.typeOfAccount,
        verificationStatus: user.verificationStatus
      },
      token
    });
  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—Ö–æ–¥–µ:', error);
    res.status(500).json({ message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
  }
};

export const logout = async (req: Request, res: Response) => {
  try {
    // –í –±—É–¥—É—â–µ–º –∑–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ª–æ–≥–∏–∫—É –¥–ª—è –∏–Ω–≤–∞–ª–∏–¥–∞—Ü–∏–∏ —Ç–æ–∫–µ–Ω–∞
    res.json({ message: '–£—Å–ø–µ—à–Ω—ã–π –≤—ã—Ö–æ–¥ –∏–∑ —Å–∏—Å—Ç–µ–º—ã' });
  } catch (error) {
    console.error('Logout error:', error);
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ –∏–∑ —Å–∏—Å—Ç–µ–º—ã' });
  }
};

export const changePassword = async (req: AuthRequest, res: Response) => {
  try {
    const { currentPassword, newPassword } = req.body;
    
    // –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª–Ω—É—é –º–æ–¥–µ–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
    const user = await User.findById(req.user?.id);
    
    if (!user) {
      return res.status(401).json({ error: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–µ–∫—É—â–∏–π –ø–∞—Ä–æ–ª—å
    const isValidPassword = await user.comparePassword(currentPassword);
    if (!isValidPassword) {
      return res.status(400).json({ error: '–ù–µ–≤–µ—Ä–Ω—ã–π —Ç–µ–∫—É—â–∏–π –ø–∞—Ä–æ–ª—å' });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –Ω–æ–≤—ã–π –ø–∞—Ä–æ–ª—å –Ω–µ —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å —Ç–µ–∫—É—â–∏–º
    const isSamePassword = await user.comparePassword(newPassword);
    if (isSamePassword) {
      return res.status(400).json({ error: '–ù–æ–≤—ã–π –ø–∞—Ä–æ–ª—å –Ω–µ –¥–æ–ª–∂–µ–Ω —Å–æ–≤–ø–∞–¥–∞—Ç—å —Å —Ç–µ–∫—É—â–∏–º' });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –Ω–æ–≤—ã–π –ø–∞—Ä–æ–ª—å –Ω–µ –±—ã–ª –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω –≤ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö 5 –ø–∞—Ä–æ–ª—è—Ö
    const isInHistory = await user.isPasswordInHistory(newPassword);
    if (isInHistory) {
      return res.status(400).json({ error: '–≠—Ç–æ—Ç –ø–∞—Ä–æ–ª—å –±—ã–ª –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω –Ω–µ–¥–∞–≤–Ω–æ. –í—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥–æ–π –ø–∞—Ä–æ–ª—å.' });
    }

    // –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–∫—É—â–∏–π –ø–∞—Ä–æ–ª—å –≤ –∏—Å—Ç–æ—Ä–∏—é
    await user.addPasswordToHistory(user.password);

    // –•–µ—à–∏—Ä—É–µ–º –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–æ–≤—ã–π –ø–∞—Ä–æ–ª—å
    const salt = await bcrypt.genSalt(10);
    user.password = await bcrypt.hash(newPassword, salt);
    user.lastPasswordChange = new Date();

    // –õ–æ–≥–∏—Ä—É–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–µ –ø–∞—Ä–æ–ª—è, –µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–æ –∂—É—Ä–Ω–∞–ª–∏—Ä–æ–≤–∞–Ω–∏–µ
    if (user.securitySettings.activityLogging.enabled) {
      await user.logActivity(
        '–ò–∑–º–µ–Ω–µ–Ω–∏–µ –ø–∞—Ä–æ–ª—è',
        req.ip || req.socket.remoteAddress || '',
        req.headers['user-agent'] || '',
        {
          method: 'change_password',
          lastPasswordChange: user.lastPasswordChange,
          passwordHistoryLength: user.passwordHistory.length,
          securityLevel: user.securitySettings.activityLogging.detailLevel
        },
        { detailLevel: user.securitySettings.activityLogging.detailLevel }
      );
    }

    await user.save();

    res.json({ message: '–ü–∞—Ä–æ–ª—å —É—Å–ø–µ—à–Ω–æ –∏–∑–º–µ–Ω–µ–Ω' });
  } catch (error) {
    console.error('Change password error:', error);
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–º–µ–Ω–µ –ø–∞—Ä–æ–ª—è' });
  }
};

export const getMe = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    if (!req.user) {
      res.status(401).json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' });
      return;
    }

    const user = await User.findById(req.user.id).select('-password');
    if (!user) {
      res.status(404).json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' });
      return;
    }

    res.json(user);
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:', error);
    res.status(500).json({ message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
  }
};

export const resetAccountLock = async (req: Request, res: Response) => {
  try {
    const { email } = req.body;
    
    if (!email) {
      return res.status(400).json({ error: 'Email –Ω–µ —É–∫–∞–∑–∞–Ω' });
    }

    const user = await User.findOne({ email });
    if (!user) {
      return res.status(404).json({ error: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' });
    }

    // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
    user.securitySettings.accountLocked = false;
    user.securitySettings.accountLockedUntil = undefined;
    user.securitySettings.failedLoginAttempts = 0;
    user.securitySettings.lastFailedLoginAttempt = undefined;

    await user.save();

    console.log(`–ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ —Å–±—Ä–æ—à–µ–Ω–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: ${email}`);
    res.json({ message: '–ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –∞–∫–∫–∞—É–Ω—Ç–∞ —É—Å–ø–µ—à–Ω–æ —Å–±—Ä–æ—à–µ–Ω–∞' });
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–±—Ä–æ—Å–µ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏:', error);
    res.status(500).json({ error: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
  }
}; 